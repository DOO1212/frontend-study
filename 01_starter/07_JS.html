<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 변수
    // 데이터를 저장할 수 있는 공간(그릇)이고 그 이름을 지정
    // 쓰는 이유? 변수에 저장해뒀다가 재사용
    const a = 2;
    const b = 5;
    // const a = 3; //(같은 범위 안에서) 동일한 이름으로 중복 선언 불가



    // const
    // 변수를 선언하는 가장 기본적인 키워드
    // 값의 재할당이 불가(상수라고 불림)
    const c = 12;
    console.log(c);

    c = 999; // 에러 발생
    console.log(c);  //실행 안됨

    // let
    // 값의 재할당이 가능
    let d = 20;
    console.log(d);

    d = 999;
    console.log(d);

    // 예약어
    // 특별한 의미와 기능을 가진 키워드로 각 언어의 시스템들이 쓰겠다고 예약해둔 것
    // 변수나 함수 등의 이름으로 사용 불가
    // const let = 'Hello';
    // const this = 123;
    // const if = true;
    // const if = true;
  </script>  
</body>
</html>

================================================================================

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 데이터 타입(자료형)

    // String(문자 데이터)
    // 큰따옴표(""), 작은따옴표(''), 백틱(``)
    const myName = "GONI";
    const email = 'geoblo@naver.com';
    const hello = `Hello ${myName}?!`; // 템플릿 리터럴(ES6차)
    // 백틱 미사용시 데이터 끼워넣기
    const concatString = 'Hello' + myName + '?!';

    console.log(myName);
    console.log(email);
    console.log(hello);
    console.log(concatString)

    // Number(숫자 데이터)
    // 정수 및 부동소수점(실수) 숫자를 나타냄
    const number = 123;
    const opacity = 0.57;

    console.log(number);
    console.log(opacity);

    // Boolean(논리 데이터)
    // true(참), (false(거짓) 두 가지 값만 존재
    // 이분법적으로 구분해야 하는 상황에서 사용
    // => 조건문/반복문에서 조건을 판단할 때
    const checked = true;
    const isShow = false;
    
    // 조건식
    const numX = 5;
    const numY = '5';
    const numZ = 6;

    console.log(numX === numY);
    console.log(numX === numZ);

    // undefined
    // 아무것도 정의되지 않은(값이 할당되지 않은) 상태를 의미
    // 변수의 초기화를 하지 않으면 자동으로 undefined가 할당
    // (초기화: 변수를 선언하고 처음으로 값을 저장하는 것)
    let undef;
    console.log(undef);

    const obj = {
      abc: 123
    };
    console.log(obj.abc);
    console.log(obj.xyz);

    // null
    // 어떤 값이 의도적으로 비어있음을 의미
    // undefined와 다른 점은 개발자가 명시적으로 값이 비었음을 나타낼 때 사용
    let name = null;
    console.log(name);

    name = 'goni.kim';
    console.log(name);

    // Object(객체 데이터)
    // 관련있는 여러 데이터를 key-value 1쌍의 형태로 저장
    // {} 방식을 주로 사용
    const user = {
      // 속성(property)
      name: 'goni.kim', // 문자
      age: 33, // 숫자
      isMarried: false // 논리
    };

    console.log(user);
    // 객체 내부에 특정 데이터만 출력
    console.log(user.name);
    console.log(user.age);
    console.log(user.isMarried);

    // Array(배열 데이터)
    // 여러 데이터를 순차적으로 저장
    // [] 방식을 주로 사용
    // 배열의 인덱스는 0부터 시작
    const fruits = ['Apple', 'Banana', 'Cherry'];

    console.log(fruits);
    //배열의 특정 데이터만 출력
    console.log(fruits[0]);
    console.log(fruits[1]);
    console.log(fruits[2]);

    // (참고) 다른 종류의 데이터를 포함시킬 수도 있지만,
    // 대부분 같은 종류의 데이터를 나열
    const arr = ['goni.kim', 33, false]

    // (활용 예) 상품 리스트, 사용자 리스트
    const productList = [
      {
        productId: 1,
        productName: '고려은단 비타민C',
        price: 32900,
        productImg: 'https://이미지경로',
        brand: '고려은단'
      }, 
      {
        productId: 2,
        productName: '콘드로이친1200',
        price: 285000,
        productImg: 'https://이미지경로',
        brand: '관절엔'
      }, 
      {
        productId: 3,
        productName: '에버콜라겐C',
        price: 210000,
        productImg: 'https://이미지경로',
        brand: '뉴트리'
      }
    ];

    console.log(productList[0].price);

    const userList = [
      {
        userId: 'geoblo',
        name: '김재현',
        age: 99,
        email: 'geoblo@naver.com',
        hobby: ['배드민턴', '싸이클', '스노우보드', '스쿼시', '탁구', '스쿠버 다이빙']
      },
      {
        userId: 'javakim',
        name: '김자바',
        age: 10,
        email: 'jsjs@gmail.com',
        hobby: ['멍때리기']
      }
    ];
    
    console.log(userList[0].hobby[2]);

    // (참고) JS는 매우 유연한 언어
    // 변수에 여러 데이터 타입을 넣을 수 있고 값을 넣은 순간에 타입이 결정됨
    // => 동적 타입 언어
    let e = 1;
    console.log(typeof e); // typeof: 데이터 타입을 체크
    e = 'abc';
    console.log(typeof e);

    // (참고) false로 취급되는 값(falsy): false, 0,''(빈문자), null, undefined, NaN(Not a Number)

  </script>  
</body>
</html>

================================================================================

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

  <style>
    body {
      height: 1000px;
    }
  </style>
</head>
<body>

  <script>
    // 함수
    // 기능(동작)을 수행하는 코드의 집합
    // 변수와 마찬가지로 한번 선언해두면 재사용이 가능

    // 함수의 선언과 호출
    // function 함수이름(매개변수) {
    //   실행 코드들
    // }

    // 매개변수는 옵션: 외부로부터 전달받은 값을 저장
    // 중괄호 블록({}): 블록 안에 실행할 코드들을 작성
    // 선언이 끝나면 필요한 곳에서 호출해서 사용 => 함수이름();

    // 함수 선언 (=> 메모리에 저장됨)
    function printNumber() {
      console.log(123);
    }

    // 함수 호출(실행)
    printNumber();
    printNumber();
    printNumber();

    // JS 코드 실행 흐름
    // 위 -> 아래로 한줄씩 실행
    // 함수 호출 시 해당 함수를 실행하고 끝나면 돌아옴

    // 함수의 데이터 반환
    // 내부에서 return 키워드를 사용하면 데이터를 반환하고 함수를 종료
    function returnFunc() {
      return 12345;
      // return; // return만 쓰면 함수 종료를 의미
      // console.log('abc'); // 실행 안됨!
    }

    const a = returnFunc(); // 실행 결과 반환되는 값을 변수 a에 할당
    // const a = 12345;
    console.log(a);

    // 매개변수가 있는 경우
    // 매개변수는 유효 범위(scope)인 함수 내에서만 사용 가능!
    function sum(num1, num2) { // num1, num2는 매개변수(Parameters)라 부름
      // 매개변수를 사용하여 함수 외부로부터 값을 받음
      return num1 + num2;
    }

    // 전달하는 데이터 1,2를 인수(인자값, 매개값,Argument라 부름)
    const result1 = sum(1,2);
    const result2 = sum(7,12);
    const result3 = sum(2,4);

    console.log(result1, result2, result3);

    // 기명(이름이 있는) 함수와, 익명(이름이 없는) 함수
    // 일반적으로 함수에는 이름이 존재하지만 때로는 없을 수도 있음
    // 함수는 그 자체가 하나의 값(데이터)으로 취급되어 변수에 할당 가능
    // 이 때는 변수의 이름이 곧 함수의 이름이 된다.

    // 기명 함수
    // 함수 선언문
    function hello() {
      console.log('Hello~');
    }
    hello();

    // 익명 함수
    // 함수 표현식
    // 이름이 없기 때문에 변수에 할당하지 않으면 재사용 불가
    const world = function () {
      console.log('World~');
    };
    world();

    // 재사용이 필요하다면 기명 함수 사용
    function handler() {
      console.log('Clicked!');
    }
    handler();
    handler();
    // JS에서 함수는 그 자체가 하나의 값이라 함수를 호출할 때 인자값으로 사용 가능 => 콜백 함수라 부름
    document.body.addEventListener('click', handler);
    // 총 3번 재사용

    // 함수를 재사용 할 필요가 없으면(1회성) 굳이 이름 붙이지 않고 익명 함수 사용
    document.body.addEventListener('click', function () {
      console.log('1회성 함수!');
    });
    // 보통 이벤트 핸들러를 익명 함수로 만듦

    // 메소드에 대해
    // 객체에 저장하는 데이터가 함수인 경우, 그 속성을 메소드라고 부름
    const user = {
      name: 'goni.kim',
      age: 33,
      getName: function () { // 메소드(method)
        return this.name;        
      }
    };
    // this는 객체 자기 자신을 가리키는 키워드
    // 자신이 속한 객체의 각 속성에 this로 접근이 가능(객체 내부에서 접근 시)

    const hisName = user.getName();
    console.log('hisName');

    // 변수 할당 없이 바로 사용해도 됨
    console.log(user.getName());

    // 차이점: 변수에 할당하면 해당 데이터를 재사용 가능,
    // 할당하지 않으면 필요할때마다 함수(메소드) 호출 필요

  </script>
  
</body>
</html>

================================================================================

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <script>
    // 조건문
    // 조건식의 결과(true/false)에 따라 다른 코드를 실행(분기)하는 구문
    // if문, switch문

    // if
    // if (값 또는 조건식) {
    //   실행코드
    // }
    let isShow = true; // 참
    const checked = false; // 거짓

    if (isShow) {
      console.log('Show!');
    }

    if (checked) {
      console.log('Checked!');
    }

    // if ~ else
    isShow = false;

    if (isShow) {
      console.log('보임!');
    } else {
      console.log('숨김!');
    }

    // if ~ else if ~ else
    const score = 80;

    if (score >= 90) {
      console.log('A등급');
    } else if (score >= 80) {
      console.log('B등급');
    } else if (score >= 70) {
      console.log('C등급');
    } else {
      console.log('D등급');
    }
  </script>
  
</body>
</html>

================================================================================

// querySelector('CSS 선택자')
// HTML에서 해당 요소를 검색하여 찾은 첫 번째 요소 하나만 반환
// 요소를 찾지 못하면 null을 반환

const boxEl = document.querySelector('.box');
console.log(boxEl);

// 요소에 이벤트 리스너 등록하기
// 이벤트: 마우스(click), 스크롤(scroll), 키보드(keydown) 등
// addEventListener() 메소드:
// 해당 요소에 지정한 이벤트(Event)가 발생하는지 듣고(Listen) 있다가
// 실제 이벤트가 발생하면 연결된 함수(Handler)를 실행

boxEl.addEventListener('click', function () {
  console.log('click!');

  // classList 속성: HTML 요소의 class 속성에 대한 제어 명령이 포함
  // 추가하기
  boxEl.classList.add('active'); // 요소에 active라는 클래스를 추가

  // 확인하기
  let hasActive = boxEl.classList.contains('active'); // 요소에 active라는 클래스 값이 있는지 확인
  console.log(hasActive);

  // 제거하기
  boxEl.classList.remove('active'); // 요소에 active라는 클래스가 있으면 제거
  hasActive = boxEl.classList.contains('active');
  console.log(hasActive);

  // 토글하기
  // if (boxEl.classList.contains('on')) {
  //   boxEl.classList.remove('on');
  // } else {
  //   boxEl.classList.add('on');
  // }

  boxEl.classList.toggle('on');
  
  // 활용 예: active라는 클래스에 미리 스타일을 지정하고 클릭한 특정 요소에 스타일을 적용할 때
  
  // 참고 링크
  // 이벤트 종류: https://www.w3schools.com/jsref/dom_obj_event.asp (<-- 한 번 정도 슥 읽어볼 것!)
  // HTML DOM 속성/메소드: https://www.w3schools.com/jsref/dom_obj_document.asp
});

================================================================================

// HTML에서 해당 요소를 검색하여 찾은 모든 요소들을 반환
const boxEls = document.querySelectorAll('.box');
console.log(boxEls); // 찾은 요소들의 리스트가 반환됨
// => 앞에서 사용한 DOM API들을 바로 쓸 수가 없음

// forEach() 메소드 사용: 배열에서 각 요소에 대한 반복 처리를 수행
// 인수(인자값)로 반복을 돌면서 꺼내온 요소를 처리하는 함수 작성
// 처리함수 작성 시 매개변수(현재 가져온 요소, 요소의 인덱스) 순서가 중요!
boxEls.forEach(function (boxEl,index) {
  console.log(index, boxEl);
  
  // boxEl.classList.add('order-' + (index + 1));
  boxEl.classList.add(`order-${index + 1}`);
});

// 요소의 내용 확인 및 수정
const boxEl = document.querySelector('.box');
console.log(boxEl.textContent); // 요소의 내용 출력

boxEl.textContent = 'CHANGE!'
console.log(boxEl.textContent);
//(참고) innerHTML: HTML 태그까지 조작하거나 삽입하고 싶을 때
boxEl.innerHTML = '<b>CHANGE!</b>';

================================================================================

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <script>
    // 메소드 체이닝: 여러 메소드를 이어서 작성
    const a = 'He-llo-IT';

    // 메소드 체이닝을 안썼을때
    const b = a.split('');
    console.log(b);
    const c = b.reverse();
    console.log(c);
    const d = c.join();
    console.log(d);

    // 메소드 체이닝을 썼을때
    const e = a.split('').reverse().join('');
    console.log(e);
    
    // 정리: 분리해서 작성하면 코드가 길어지니까 필요에 따라 메소드 체이닝을 사용

    // split: 문자를 인수 기준으로 쪼개서 배열로 반환
    // reverse: 배열을 뒤집기
    // join: 배열을 인수 기준으로 문자로 병합해 반환
    
  </script>
  
</body>
</html>

================================================================================

